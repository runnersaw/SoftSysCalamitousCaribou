###Overview
This code demonstrates format string exploits. These vulnerabilities occur when a function that takes string 
formats as inputs like `printf()` is exposed to user input. Mentally, I think of this as the C equivalent of 
SQL injection.  

This guide is based off of [this website](http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html) More in depth explanation 
is provided there

`printf()` can take any number of inputs, the only way it knows how many to expect is by looking at the format string it is passed.
`printf(%p %d %i)` expects three arguments. If three arguments are not given, it will grab the next three address off of the stack
and use those as arguements.

Using the `%n` formatter we can write values to memory addresses. This formatter does the following: `
> The number of characters written so far is stored into the integer indicated by the int * (or variant) pointer argument. No argument is converted.

###Process
Using this information we are going to try to open a system shell by exploiting this code:
```
#include <stdio.h>
#include <string.h>
// compile with gcc -m32 temp.c

int main(int argc, char** argv) {
  printf(argv[1]);
  strdup(argv[1]);
}
```

To do this we must:
- Find the memory address for `strdup()`
- Find the memory address for `system` (The shell)
- Overwrite the memory address for `strdup()` with a pointer to the memory address for `system`

####Find the memory address for `strdup()`
- Compile the program `gcc test.c -m32`
- view the compiled object `objdump -d a.out`
- You should see in the output a section with `<strdup@plt> with a jmp command. the memory address to the right 
is the memory address of this function.
- Write this down. On my computer it is  `0x804a010`

